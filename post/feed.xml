<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 北极狼徒</title>
    <link>/post/</link>
    <description>Recent content in Posts on 北极狼徒</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 05 Jun 2020 22:10:46 +0800</lastBuildDate>
    
	<atom:link href="/post/feed.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Makefile 中的变量</title>
      <link>/post/variable_in_makefile/</link>
      <pubDate>Fri, 05 Jun 2020 22:10:46 +0800</pubDate>
      
      <guid>/post/variable_in_makefile/</guid>
      <description>Makefile 中的变量 变量的概念比较容易理解，毕竟任何语言都存在。在 Makefile 中，变量的意义也是一样的。不过不同 语言的变量表现形式可能不大一样，比如在 Makefile 中，变量</description>
    </item>
    
    <item>
      <title>windows 上编译 ccls</title>
      <link>/post/build_ccls_on_windows/</link>
      <pubDate>Thu, 04 Jun 2020 21:42:44 +0800</pubDate>
      
      <guid>/post/build_ccls_on_windows/</guid>
      <description>ccls ccls 是一个优秀的 c/c++ 语言自动补全服务端程序。虽然之前在 windows 上成功编译过一次，但是由于当时没记录下来，导致本次编译出错一时想不起来了。所以说好记性</description>
    </item>
    
    <item>
      <title>在win10上使用hyper-v共享文件夹给linux系统</title>
      <link>/post/share_dir_on_hyper-v/</link>
      <pubDate>Thu, 14 May 2020 07:36:20 +0800</pubDate>
      
      <guid>/post/share_dir_on_hyper-v/</guid>
      <description>windows 文件夹共享 这里只需要简单的几步就可以实现 windows 目录的共享功能。具体过程如下： 在你需要共享的目录右键，选择属性 选择共享按钮，点击中间的高级共享 勾</description>
    </item>
    
    <item>
      <title>像VSCode一样使用vim</title>
      <link>/post/use_vim_as_vscode/</link>
      <pubDate>Fri, 01 May 2020 19:18:12 +0800</pubDate>
      
      <guid>/post/use_vim_as_vscode/</guid>
      <description>谈谈VSCode VScode 是微软公司开源的一款非常优秀的编辑器，本人也是非常喜欢。 但是早期养成了使用 spacemacs的习惯，后因为开启速度问题，转</description>
    </item>
    
    <item>
      <title>使用 make 管理工程项目</title>
      <link>/post/manage_project_with_make/</link>
      <pubDate>Thu, 30 Apr 2020 19:58:52 +0800</pubDate>
      
      <guid>/post/manage_project_with_make/</guid>
      <description>谈谈 make 首先简单讲讲 make 吧，但感觉又没必要讲，几乎所有的程序都知道，尤其是在linux环境下工作过的程序员。make 就是一个自动化构建工具，用于</description>
    </item>
    
    <item>
      <title>Linux 内核学习 ——— 系统调用</title>
      <link>/post/oslab_syscall/</link>
      <pubDate>Thu, 23 Apr 2020 09:54:13 +0800</pubDate>
      
      <guid>/post/oslab_syscall/</guid>
      <description>系统调用 实验内容 在linux0.11上添加两个系统调用iam()和whoami，分别用于向内核空间存字符串和取字符串。 添加步骤 在 include/unistd.h 中添加系统</description>
    </item>
    
    <item>
      <title>Linux内核学习 ———— 系统引导</title>
      <link>/post/oslab_experiment_01/</link>
      <pubDate>Thu, 23 Apr 2020 00:00:00 +0800</pubDate>
      
      <guid>/post/oslab_experiment_01/</guid>
      <description>实验目的 了解操作系统的加载过程 实验内容 修改bootsect.s程序：实现打印一个字符串 修改setup.s 程序：实现打印字符串并打印至少一个硬</description>
    </item>
    
    <item>
      <title>代码片段 For VSCode</title>
      <link>/post/my_snippets/</link>
      <pubDate>Tue, 21 Apr 2020 00:00:00 +0800</pubDate>
      
      <guid>/post/my_snippets/</guid>
      <description>写作目的 每次新换一个环境，就需要重新整理 snippets, 干脆直接记录在博客上。 markdown 插入标题 &amp;#34;head 1&amp;#34;: { &amp;#34;prefix&amp;#34;: &amp;#34;h1&amp;#34;, &amp;#34;body&amp;#34;: &amp;#34;# $1\n&amp;#34; }, &amp;#34;head 2&amp;#34;: { &amp;#34;prefix&amp;#34;: &amp;#34;h2&amp;#34;, &amp;#34;body&amp;#34;: &amp;#34;## $1\n&amp;#34; }, &amp;#34;head 3&amp;#34;: { &amp;#34;prefix&amp;#34;: &amp;#34;h3&amp;#34;, &amp;#34;body&amp;#34;: &amp;#34;### $1\n&amp;#34; }, &amp;#34;head 4&amp;#34;: { &amp;#34;prefix&amp;#34;: &amp;#34;h4&amp;#34;, &amp;#34;body&amp;#34;:</description>
    </item>
    
    <item>
      <title>Linux 内核学习 — 实验环境</title>
      <link>/post/oslab_env/</link>
      <pubDate>Mon, 20 Apr 2020 22:21:06 +0800</pubDate>
      
      <guid>/post/oslab_env/</guid>
      <description>编译环境 这里选择轻量级的 Lubuntu，版本为19.10。 oslab环境搭建 感谢 Wangzhike提供开源的一键配置环境。 安装包下载 git clone https://github.com/Wangzhike/HIT-Linux-0.11.git 环</description>
    </item>
    
    <item>
      <title>Too many open files 解决办法</title>
      <link>/post/how_to_open_over_1024_files/</link>
      <pubDate>Sun, 15 Sep 2019 18:50:19 +0800</pubDate>
      
      <guid>/post/how_to_open_over_1024_files/</guid>
      <description>问题来源 Linux 系统默认能打开的文件个数上限是 1024 个，可通过 limits -n 查看，但实际上系统可打开的文件个数远超过这个限制，通过 cat /proc/sys/fs/file-max 可以看到，在我的 64 位机器上</description>
    </item>
    
    <item>
      <title>Linux 内核设计与实现 — 虚拟文件系统</title>
      <link>/post/linux_kernel_design_and_impl_ch13/</link>
      <pubDate>Sun, 07 Jul 2019 12:48:54 +0800</pubDate>
      
      <guid>/post/linux_kernel_design_and_impl_ch13/</guid>
      <description>虚拟文件系统作为内核子系统，为用户空间程序提供文件和文件系统相关操作的接口。系统中各文件系统依赖虚拟文件系统共存并协同工作。通过 vfs , 用户空间</description>
    </item>
    
    <item>
      <title>Linux 内核设计与实现 — 内存管理</title>
      <link>/post/linux_kernel_design_and_impl_ch12/</link>
      <pubDate>Sun, 23 Jun 2019 13:23:07 +0800</pubDate>
      
      <guid>/post/linux_kernel_design_and_impl_ch12/</guid>
      <description>内核的内存分配相比用户空间来说相对较为困难，主要是因为内核本身不能奢侈的使用内存，而且一般不能睡眠，处理内存分配错误也比较棘手。 页 内核将物理</description>
    </item>
    
    <item>
      <title>Linux 内核设计与实现 — 时间管理</title>
      <link>/post/linux_kernel_design_and_impl_ch11/</link>
      <pubDate>Thu, 20 Jun 2019 20:52:58 +0800</pubDate>
      
      <guid>/post/linux_kernel_design_and_impl_ch11/</guid>
      <description>内核中有很多基于时间驱动的函数，如调度程序中运行队列进行平衡调整或对屏幕进行刷新等。时间管理中需注意相对时间和绝对时间的差别以及周期性事件和</description>
    </item>
    
    <item>
      <title>Linux 内核设计与实现 — 内核同步</title>
      <link>/post/linux_design_and_impl_ch09/</link>
      <pubDate>Wed, 12 Jun 2019 20:40:09 +0800</pubDate>
      
      <guid>/post/linux_design_and_impl_ch09/</guid>
      <description>在进行多线程编程时，我们要特意留意共享数据的保护，防止并发访问时多个线程同时操作 导致的结果不一致性。 Linux 2.0 开始内核开始支持 SMP. 所以内核可以在同一</description>
    </item>
    
    <item>
      <title>Linux 内核设计与实现 — 下半部</title>
      <link>/post/linux_kernel_design_and_impl_ch08/</link>
      <pubDate>Sun, 09 Jun 2019 15:11:35 +0800</pubDate>
      
      <guid>/post/linux_kernel_design_and_impl_ch08/</guid>
      <description>内核为处理中断提供了中断处理程序机制，这是内核必不可少的一部分。但仍然存在一些局 限： 中断程序异步执行，可能打断其它重要代码的执行；因此中断处</description>
    </item>
    
    <item>
      <title>Linux 内核设计与实现 — 内核数据结构</title>
      <link>/post/linux_kernel_design_and_impl_ch06/</link>
      <pubDate>Fri, 07 Jun 2019 22:09:18 +0800</pubDate>
      
      <guid>/post/linux_kernel_design_and_impl_ch06/</guid>
      <description>本章节的内容是一些数据结构，没甚么可说的。随便记记笔记吧。内容包括链表、队列、映 射、二叉树。 链表 这是 linux 中最简单的数据结构，是一种存放客可变数</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 对象模型 — Function 语意学</title>
      <link>/post/cpp_object_models_ch04/</link>
      <pubDate>Mon, 03 Jun 2019 22:26:04 +0800</pubDate>
      
      <guid>/post/cpp_object_models_ch04/</guid>
      <description>调用方式 普通函数 虚函数 静态函数 非静态成员函数 C++ 设计准则之一：非静态成员函数至少和非成员函数效率一样。 成员函数内化为非成员函数的过程： 改写函数</description>
    </item>
    
    <item>
      <title>Linux 内核设计与实现 — 系统调用</title>
      <link>/post/linux_kernel_design_and_impl/</link>
      <pubDate>Sat, 01 Jun 2019 22:21:06 +0800</pubDate>
      
      <guid>/post/linux_kernel_design_and_impl/</guid>
      <description>三个作用 为用户空间提供硬件抽象接口 保证系统稳定和安全 使每个用户程序运行在虚拟系统中 系统调用 定义一个系统调用(以 getpid() 为例)： SYSCALL_DEFINE0(getpid) { return task_tgid_vnr(current); // return current-&amp;gt;tgid } SYSCALL_DEFINE0 是</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 对象模型 — Data 语义学</title>
      <link>/post/cpp_object_models_ch03/</link>
      <pubDate>Tue, 28 May 2019 23:18:19 +0800</pubDate>
      
      <guid>/post/cpp_object_models_ch03/</guid>
      <description>对象大小 语言本身所造成的额外负担，如虚基类 编译器对于特殊情况的优化处理，如某些编译器对空虚基类的特殊支持，一般放在头部 就省去 1 byte 大小的空间 字</description>
    </item>
    
    <item>
      <title>Linux 内核设计与实现 — 进程调度</title>
      <link>/post/linux_kernel_design_and_impl_ch04/</link>
      <pubDate>Sat, 25 May 2019 23:05:31 +0800</pubDate>
      
      <guid>/post/linux_kernel_design_and_impl_ch04/</guid>
      <description>进程调度 进程是程序的运行态的表现形式 进程调用是确保程序有效工作的内核子系统 多任务 并发交互的执行多个进程的操作系统 抢占式 : 由调度程序决定什么时</description>
    </item>
    
    <item>
      <title>linux 设计与实现 — 进程管理</title>
      <link>/post/linux_kernel_design_and_impl_ch02/</link>
      <pubDate>Sun, 19 May 2019 21:02:15 +0800</pubDate>
      
      <guid>/post/linux_kernel_design_and_impl_ch02/</guid>
      <description>进程 进程：处于执行期的程序的实时结果 文件描述符 挂起的信号 内核内部数据 处理器状态 一个或多个内存映射地址 一个或多个执行线程 (执行)线程： 进程中的</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 对象模型 — 构造语义学</title>
      <link>/post/cpp_object_models_ch02/</link>
      <pubDate>Fri, 17 May 2019 21:57:43 +0800</pubDate>
      
      <guid>/post/cpp_object_models_ch02/</guid>
      <description>默认构造函数 在ARM(Annotated Reference Manual) 中：默认构造函数在 需要的 时候由编译器产生 产生出来。这里的需要为编译器需要，而不是程序需要，程序需</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 对象模型 — 关于对象</title>
      <link>/post/cpp_object_models_ch01/</link>
      <pubDate>Tue, 07 May 2019 23:36:30 +0800</pubDate>
      
      <guid>/post/cpp_object_models_ch01/</guid>
      <description>关于对象 面向过程 在 C 语言中, 我们通常将 数据 和 处理数据的操作(函数) 分开声明, 也就是说语言本身没有支持 数据和函数 之间的关联性. 这种程序为典型的</description>
    </item>
    
    <item>
      <title>关于内存配置器的一些总结</title>
      <link>/post/about_memory_allcates/</link>
      <pubDate>Fri, 26 Apr 2019 20:12:02 +0800</pubDate>
      
      <guid>/post/about_memory_allcates/</guid>
      <description>概述 内存管理 我们通常说的内存管理是操作系统内核提供的功能之一，也就是对于虚拟内存的管理。可以 分为以下几个不同的层次。 操作系统： 内核对虚拟内存</description>
    </item>
    
    <item>
      <title>命令行艺术(3) ~~ 文件及数据处理篇</title>
      <link>/post/the_art_of_command_03/</link>
      <pubDate>Sun, 10 Mar 2019 09:32:42 +0800</pubDate>
      
      <guid>/post/the_art_of_command_03/</guid>
      <description>查找 文件查找 内容查找 数据处理 文件处理 内容处理 数据统计 文件拷贝 杂项 查找 文件查找 在当前目录下通过文件名查找一个文件，使用类似于这样的命令：fin</description>
    </item>
    
    <item>
      <title>命令行艺术 (2) ~~ 日常使用篇</title>
      <link>/post/the_art_of_command_02/</link>
      <pubDate>Sat, 02 Mar 2019 09:43:05 +0800</pubDate>
      
      <guid>/post/the_art_of_command_02/</guid>
      <description>Table of Contens 常用快健键 一般快捷键 编辑器相关 历史命令 路径相关 少用但非常有用的命令 管理相关 使用别名 同步配置 脚本相关 善用文档 分屏管理 远程登录 杂项 常用快健</description>
    </item>
    
    <item>
      <title>命令行艺术 (1) ~~ 基础篇</title>
      <link>/post/the_art_of_command_01/</link>
      <pubDate>Sun, 24 Feb 2019 09:54:13 +0800</pubDate>
      
      <guid>/post/the_art_of_command_01/</guid>
      <description>Table of Contens 什么命令行 让命令行人性化 基础命令 私人神器zsh 熟悉环境 帮助命令 编辑命令 重定向 通配符 任务管理工具 远程登录 文件管理工具 网络管理工具 版本控制</description>
    </item>
    
    <item>
      <title>关于对象那些事儿 ~~ 继承</title>
      <link>/post/about_cpp_inherits/</link>
      <pubDate>Fri, 22 Feb 2019 20:07:56 +0800</pubDate>
      
      <guid>/post/about_cpp_inherits/</guid>
      <description>Table of Contens 关于继承 何为对象 何为继承 public 继承 public 继承权限 实例 protected 继承 protected 继承权限 实例 private 继承 protected 继承权限 实例 虚继承 实例 虚继承与虚函数 总结 关于继承 随着软件功能的</description>
    </item>
    
    <item>
      <title>动手写编辑器（四） ~ 文本编辑器</title>
      <link>/post/write_textor_4/</link>
      <pubDate>Sun, 17 Feb 2019 16:51:33 +0800</pubDate>
      
      <guid>/post/write_textor_4/</guid>
      <description>Table of Contens 文本编辑器 插入字符 重新映射方向键 按键处理 插入字符 删除字符 删除字符 添加行 换行 修改提示 保存文件 退出提示 另存为 效果 总结 参考 文本编辑器 在之前的</description>
    </item>
    
    <item>
      <title>动手写编辑器 (三) ~ 文件查看器</title>
      <link>/post/write_textor_3/</link>
      <pubDate>Sat, 02 Feb 2019 13:27:35 +0800</pubDate>
      
      <guid>/post/write_textor_3/</guid>
      <description>Table of Contens 状态栏 腾出空间 写入 buffer 消息框 腾出空间 滞留时间 写入消息 写入 buffer 滚动 垂直滚动 水平滚动 修改边界检查 写入 buffer 总结 参考 状态栏 熟悉 vim 的朋友都知道, vim 有一</description>
    </item>
    
    <item>
      <title>动手写编辑器（二） ~ 输入和输出</title>
      <link>/post/write_textor_2/</link>
      <pubDate>Wed, 30 Jan 2019 11:06:21 +0800</pubDate>
      
      <guid>/post/write_textor_2/</guid>
      <description>Table of Contens 窗口 Buffer 窗口 size 波浪线 欢迎界面 输入 Ctrl+q 退出 移动光标 文本内容 输出 显示 buffer 刷新屏幕 总结 参考 窗口 说到终端编辑器， vim 应该是用的最多的吧。在所有有关 Linux 基</description>
    </item>
    
    <item>
      <title>动手写编辑器(一) ~ 文本模式</title>
      <link>/post/write_textor_1/</link>
      <pubDate>Sun, 20 Jan 2019 18:31:32 +0800</pubDate>
      
      <guid>/post/write_textor_1/</guid>
      <description>Table of Contens 写作动机 规范模式 文本模式 设置属性 本地模式标志 ~~ c_lflag 输入模式标志 ~~ c_iflag 输出模式标志 ~~ c_oflag 杂项标志 开启和关闭文本模式 总结 参考 写作动机 因为是该项目</description>
    </item>
    
    <item>
      <title>手把手实现一个 Linux shell</title>
      <link>/post/writh_shell_with_cpp/</link>
      <pubDate>Sat, 19 Jan 2019 20:17:47 +0800</pubDate>
      
      <guid>/post/writh_shell_with_cpp/</guid>
      <description>Table of Contens Linux shell 基本知识 shell 工作流程 shell 实现 可执行程序该有的样子 一探循环体究竟 解剖循环体 总结 参考 Linux shell 基本知识 目前市场上主要有三大主流操作系统，除了 windows 系</description>
    </item>
    
    <item>
      <title>树结构及其应用场景总结</title>
      <link>/post/data_struct_trees_conclusion/</link>
      <pubDate>Sat, 05 Jan 2019 00:00:00 +0800</pubDate>
      
      <guid>/post/data_struct_trees_conclusion/</guid>
      <description>Table of Contens 数据结构 &amp;ndash; 树 二叉树 二叉查找树 平衡二叉树 B树 B+树 B*树 字典树/Trie树 基数树/radix树 树的应用 参考 数据结构 &amp;ndash; 树 树是学习数据结构必</description>
    </item>
    
    <item>
      <title>Gentoo 系统初探</title>
      <link>/post/gentoo_linux_first_try/</link>
      <pubDate>Sat, 22 Dec 2018 00:00:00 +0800</pubDate>
      
      <guid>/post/gentoo_linux_first_try/</guid>
      <description>Table of Contens 安装准备 系统镜像 虚拟软件 启动系统 配置网络 准备磁盘 创建分区 创建文件系统 挂载根分区 安装 stage3 配置编译选项 基本系统 镜像站点 复制 DNS 信息 挂载必要的文</description>
    </item>
    
  </channel>
</rss>