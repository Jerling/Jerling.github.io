<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Post on 北极狼徒</title>
    <link>/post/</link>
    <description>Recent content in Post on 北极狼徒</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 02 Feb 2019 13:27:35 +0800</lastBuildDate>
    
	<atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>动手写编辑器 (三) ~ 文件查看器</title>
      <link>/post/write_textor_3/</link>
      <pubDate>Sat, 02 Feb 2019 13:27:35 +0800</pubDate>
      
      <guid>/post/write_textor_3/</guid>
      <description>Table of Contens  状态栏  腾出空间 写入 buffer  消息框  腾出空间 滞留时间 写入消息 写入 buffer  滚动  垂直滚动 水平滚动 总结 参考   状态栏 熟悉 vim 的朋友都知道, vim 有一个状态栏，位于下边。状态栏的功能主要时显示一些基 本的信息，如文件名、光标位置等。
腾出空间 在之前的操作中，我们把整个窗口都用来显示文件内容了。所以我们必须将 rows_ 减去 一行用来显示状态信息。
inline int editor::get_window_size__() { ... rows_ = ws.ws_row - 1; /* 腾出状态栏 */ ... }  写入 buffer 现在将我们要显示的信息写入 buffer 的最后一行，也就是状态栏。为了区分状态栏和文本 区的不同，因此将颜色反转。
void editor::status_bar__() { append_buf__(&amp;quot;\x1b[7m&amp;quot;); /* 颜色反转 */ std::string stats((filename_.empty() ?</description>
    </item>
    
    <item>
      <title>动手写编辑器（二） ~ 输入和输出</title>
      <link>/post/write_textor_2/</link>
      <pubDate>Wed, 30 Jan 2019 11:06:21 +0800</pubDate>
      
      <guid>/post/write_textor_2/</guid>
      <description>Table of Contens  窗口  Buffer 窗口 size 波浪线 欢迎界面  输入  Ctrl+q 退出 移动光标 文本内容  输出  显示 buffer 刷新屏幕  总结  窗口 说到终端编辑器， vim 应该是用的最多的吧。在所有有关 Linux 基础的书本都会介绍 vi/vim 编辑器。因此在这里我将模仿 vim 编辑界面。话不多说，先看一下 vim 的启动界 面吧。
  左边的波浪号表示没有内容的行，中间显示打开编辑器时的欢迎界面以及基本命令信息。现 在就模仿 vim 的界面，实现一个简单的编辑器。下面我们来将这个界面画出来。
Buffer Buffer 是编辑器的主体部分，所有的信息都只能通过 buffer 显示。 buffer 里面是一串 很长的字符串，其中有些是转义序列表示终端的一些命令，在后续需要用到的时候再讲解。 说起字符串处理，应该是最常见的操作了，用 C 写的话可能需要自己管理字符串，比如申 请内存，释放内存等，不需要多线程，因此不需要考虑线程安全。我们直接使用 C++ 的 string 数据类型即可。
struct editor{ ... /* buffer */ std::string abuf_; .</description>
    </item>
    
    <item>
      <title>动手写编辑器(一) ~ 文本模式</title>
      <link>/post/write_textor_1/</link>
      <pubDate>Sun, 20 Jan 2019 18:31:32 +0800</pubDate>
      
      <guid>/post/write_textor_1/</guid>
      <description>Table of Contens  写作动机 规范模式 文本模式 设置属性  本地模式标志 ~~ c_lflag 输入模式标志 ~~ c_iflag 输出模式标志 ~~ c_oflag 杂项标志  开启和关闭文本模式 总结  写作动机 因为是该项目的第一篇文章，在这里简单介绍实现该项目的动机。作为程序员，动手能力是 第一位的，不管看了多少经典书籍、亦或浏览过多少源码。如果没有自己动手去实现，这些 东西都不是自己的。本人可以说是一个编辑器爱好者吧，前前后后折腾过 N 多编辑器： 如编辑器之神 Vim, 神的编辑器 Emacs, 性感无比 Sublime text 以及宇宙最强 VSCode. 最终本人留下了 emacs 和 VSCode , 前者用于编程和写作，后者用于调试程序。 用了这么多的编辑器，是时候自己实现一个了。当然并不打算参与竞争，单纯为了学习。再 说了，目前我的 emacs+doom 已经能处理各种写作任务，而且我很享受在上面码字，就想 弹钢琴一样，无须鼠标干扰，安心写作。Ok~ 让我们开始一段奇妙的旅行吧～～～
规范模式 我们平常使用的交互式命令终端就是所谓的 canonical mode。简单来说就是，它每次接收一行文本， 允许通过退格键进行删除输入的内容，以 enter 作为发送触发键发送给程序，然后程序 对其进行响应。这种模式大多用于交互命令处理中。但是用在文本编辑器(如 nano)中 显然是不合适，因为它要处理的是每一个按键(包括 enter)。
文本模式 文本模式(raw mode)可以不处理 enter 触发的发送功能，而是把其作为键值进行处理。这个才 接近文本编辑器的要求。但是呢，终端默认都是规范模式，而且这两个模式之间的差别不仅 仅是这一个，而且要完全切换会涉及很多的标志位的设置。下面我们就一步步来让终端来实 现期望的文本模式。</description>
    </item>
    
    <item>
      <title>手把手实现一个 Linux shell</title>
      <link>/post/writh_shell_with_cpp/</link>
      <pubDate>Sat, 19 Jan 2019 20:17:47 +0800</pubDate>
      
      <guid>/post/writh_shell_with_cpp/</guid>
      <description>Table of Contens  Linux shell 基本知识 shell 工作流程 shell 实现  可执行程序该有的样子 一探循环体究竟 解剖循环体  总结 参考  Linux shell 基本知识 目前市场上主要有三大主流操作系统，除了 windows 系列几乎不需要在终端工作，其它两 大操作系统大部份应该是和终端打交道。当然这和不同系统的定位不一样有很大的关系， W 系主要面向娱乐办公，Linux 系主要是用服务器系统，所以对于程序员来说，或多或少得面 对它。Mac 虽然面向个人用户，但是结合了前两者的优势，娱乐办公和开 发都可以完美应对。在使用 *nix(linux &amp;amp; Mac) 过程中，我们几乎每天都会对着终端一行 行的执行代码，解释我们的名令的程序就是我们所谓的 shell, 也是本文的所讲的对象。 shell 自从诞生以来，也出现各种版本，虽然实现不同，功能都是一样的。本文写个 shell 只是为了学习，没有其它目的。据本人所知，目前流行的 shell 有： bash , zsh , fish , xosh 等，这几种 shell 本人都用过，简单讲奖各自的特点吧， bash 不用说了吧，几乎 所有发行版的默认 shell。 zsh 集装逼与高效于一身的 shell。强烈建议于 oh-my-zsh 一 起使用，省去配置的时间。 fish 小众软件，智能补全，拥有类似 apt 一样的插件管理工 具，但是由于 shell 语法和 bash 不兼容，建议个人使用，不要用于工作中。 xosh 是用 python 实现的，所以终端直接执行 python 语句就可以执行，同时可以执行系统命令。 pythoner 可以尝试一波，随时随地测试 python 语句。</description>
    </item>
    
    <item>
      <title>树结构及其应用场景总结</title>
      <link>/post/data_struct_trees_conclusion/</link>
      <pubDate>Sat, 05 Jan 2019 00:00:00 +0800</pubDate>
      
      <guid>/post/data_struct_trees_conclusion/</guid>
      <description>Table of Contens  数据结构 &amp;ndash; 树  二叉树 二叉查找树 平衡二叉树 B树 B+树 B*树 字典树/Trie树 基数树/radix树  树的应用 参考  数据结构 &amp;ndash; 树 树是学习数据结构必学的一种结构之一，其重要性不言而喻。本文对自己已知的树结构总结，如若有错，请在评论去留言，鄙人及时修改，以免误导别人。本文涉及的树结构包括：二叉树、二叉搜索树、基数树等。
二叉树 二叉树是树家族结构中最为基础的一种数据结构。
定义  每个结点最多两个子结点，即度 &amp;lt;= 2 子结点区分为左右子结点，顺序不能反过来，否则为不同的二叉树 第 i 层最多有 2i-1 个结点 深度为 k 的二叉树最多有 2k - 1个结点，即满二叉树 对任一二叉树，叶结点数n0 和 度为2的结点数 n2 的关系式为：n0 = n2 + 1  示例   特殊二叉树 在二叉树中存在满二叉树和完全二叉树两种特殊树结构。
 满二叉树
 定义
除叶结点外，其它结点都有两个结点，即度为2。此时的二叉树结点数达到最大值：2h - 1。(h 为深度)
 性质
 叶结点数： 2h 第 k 层的结点数是：2k-1 总结点数是：2h - 1，且一定是奇数(废话)   完全二叉树</description>
    </item>
    
    <item>
      <title>Gentoo 系统初探</title>
      <link>/post/gentoo_linux_first_try/</link>
      <pubDate>Sat, 22 Dec 2018 00:00:00 +0800</pubDate>
      
      <guid>/post/gentoo_linux_first_try/</guid>
      <description>Table of Contens  安装准备  系统镜像 虚拟软件 启动系统  配置网络 准备磁盘  创建分区 创建文件系统 挂载根分区  安装 stage3  配置编译选项  基本系统  镜像站点 复制 DNS 信息 挂载必要的文件系统 进入新环境 挂载 boot 分区 选择配置文件 更新 @world 集合 设置时区 配置地区  编译内核  安装源码 配置内核 编译和安装内核  配置系统  配置 fstab 文件 网络信息  系统工具  日志工具 文件索引 远程访问 文件系统工具 网络工具  安装引导  重启系统  后记  添加用户 清理垃圾  总结  系统安装 安装软件  参考链接  安装准备 Gentoo 一直是一个特别的存在，号称极客系统。网上对其推(装)崇(逼)备(必)至(备)。作为一个爱装逼的骚年，自然是想一探究尽。关于它的介绍，这里就不说了， 因为想挑战它的 Geeker 肯定都知道，如果没听过，还是选择隔壁 manjaro 。manjaro 是基于另一个优秀的发行版 Arch Linux，就是很贴心的省去了痛苦的 安装过程。想体验 Geeker 的成就感， Gentoo 和 Arch Linux 选择其中一个即可。这两者的区别是前者安装软件默认从源代码编译，而后者人性化一点，使用二进制安装包。 安装速度不知快了多少倍。也不知这些极客怎么忍受的，不过 Gentoo 的滚动更新没有 Arch 哪么快，所以安装完必要的软件之后就不须要频繁的更新，而 Arch 三天两头就可以 滚一滚了。</description>
    </item>
    
  </channel>
</rss>