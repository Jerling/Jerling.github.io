+++
title = "kvmtool 开启网络功能"
author = ["Jerling"]
description = "用 ssh 远程连接 kvm 中的虚拟机"
date = 2020-10-11
lastmod = 2020-10-11
tags = ["kvm", "ssh", "tun/tap"]
categories = ["虚拟化"]
type = "post"
draft = false
author_homepage = "https://github.com/Jerling"
toc = "true"
+++

## 前言

在用 kvmtool 启动 kvm 中的虚拟机之后，会进入一个终端窗口，而由于这个窗口是模拟的终端
窗口。因此通常会存在一些使用不便的问题，比如说虚拟机的窗口大小就和主机中的终端窗口大
小不一致。如下图所示：

![](/images/Snipaste_2020-10-11_13-53-31.png)

因此，这里想到一个办法通过 ssh 远程连接内部的虚拟机，从而规避这个缺陷。

## kvmtool 中的网络

通过简单的阅读 kvmtool 的使用文档，可以很容易找到 kvmtool 是支持网络的。
只需要增加 `--network virtio` 参数即可。至于这个参数到底做了什么，我们后续
系列文章再详细讲解，先把手头上的问题解决了。根据文档运行命令，会出现以下错误：

![](/images/Snipaste_2020-10-11_13-56-43.png)

从图片中也可以清楚的看到，是无法打开 `/dev/net/tun`，但是再系统确实存在这个设备，再
看下面的提示，可以看到 kvmtool 需要请求 TAP 设备。这个又是个啥呢？

## Liunx 中的 tun/tap

在一番查询之后，可以确定的是 tun/tap 是一种运行在操作系统内核的虚拟网络设备, 
是纯软件实现的。而它们本身
是一种计算机网络术语，tun 模拟第二层的以太网数据装帧，tap 模拟第三层的 ip 数据封包。
其中 Linux 内核的主线中已经实现了这两种虚拟设备。所以 kvmtool 就利用 tun/tap 技术达到与 kvm 中虚拟机
进行网络通信的目的。详细请看后文的博客链接。

### 启动 tun/tap 模块

首先运行 `modinfo tun` 命令，如果出现以下结果：

![](/images/Snipaste_2020-10-11_14-04-12.png)

恭喜你，你的主机已经支持 tun 了，你应该可以直接使用 tun 模块。如果无法使用,
自己手动加载一下即可：`modprobe tun`。

#### 编译 tun/tap 模块 

首先你要下载一份和你主机版本相差不大的 linux 内核。不然可能会存在执行格式不匹配错误。
本人的主机内核版本是 5.8.14 ，而手头有一份 5.8.9 的内核源码。因此直接编译 5.8.9
的内核试试。

首先进入 linux 内核源码树的根目录，执行 `make menuconfig` , 将 tun/tap 设置为编译内核
模块，具体位置如图所示：

![](/images/Snipaste_2020-10-11_13-58-00.png)

接着运行 `make -j4` ，泡杯咖啡，静静的等到它编译完毕即可。
在 `drivers/net` 下会生成对应的 ko 文件：

![](/images/Snipaste_2020-10-11_13-58-41.png)

#### 使用 tun/tap 模块

将编译好的 tun.ko 文件放入 `/lib/modules/5.8.14-arch1-1/kernel/net` 目录下。注意这里的 `5.8.14-arch1-1`
是和你使用的发行版有关系，本人用的是 Arch linux。因此适当修改即可。接着重启主机。

主机重启完之后，再看一下 tun 模块信息：

![](/images/Snipaste_2020-10-11_14-07-58.png)

如果没有得到上述结果，那么运行 `sudo depmod` 试试。

#### 加载 tun/tap 模块 

接着我们需要将 tun.ko 加载到主机的内核中, `sudo modprobe tun`，之后查看一下网络接口：

![](/images/Snipaste_2020-10-11_14-09-15.png)

可以看到，的确多了一个虚拟网口，设备名为 `tap0`。

## kvmtool 启用网络

现在我们继续执行一下命令：`sudo lkvm run --kernel ./bzImage --disk arch.img --network virtio`

可以发现，kvm 虚拟机正常启动了。

接下来我们只需要正确的设置 ip 地址即可:
![](/images/Snipaste_2020-10-11_15-16-31.png)

这里设置的 ip 前缀需与主机的 tap0 接口一致，即 `192.168.33`. 后面的数字可以根据实际情况
自己设置，范围在 `2~254` 之间。
## 主机 ssh 连接虚拟机

注意，这里必须要注意咯。之前介绍怎么做根文件系统，但是那个文件系统里面只包含了最基本的工具，像 ssh 服务程序是
没有的，需要自己编译然后放进去。

这里为了避免麻烦，本人将自己主机上的应用程序直接打包成根文件系统进行测试。所以想节省时间成本的小伙伴可以
参考我的做法。

因为我的主机设置了 sshd 服务为开机启动，因此虚拟机启动的时候，ssh 服务也就启动了。如果没有，执行命令：
`systemctl start sshd`。如果还是没有启动，检查一下主机是否安装了 sshd 服务程序。

接着就是从主机连接虚拟机了，效果如下：
![](/images/Snipaste_2020-10-11_14-16-51.png)

可以看到，窗口大小和主机的窗口大小一致了，不会出现中间截断的现象。

除了这个好处之外，有了网络就可以将代码直接上传到虚拟机中进行编译，而无需在主机上编译完，放入根文件系统中，
再启动虚拟机使用了。

## 结束语

最后，我们可以注意到，各种发型版如 Redhat，Debian 等，其实就是用户态的程序集合不一样，内核其实是一样的。
如果你的野心足够大，可以自己做一个根文件系统，里面包含各种程序集合，再安装一个安装程序，并打包成一个可启动
的系统镜像，你就得到了自己的发现版。是不是突然感觉做一个发行版也不是很难呢？

当然上面只是鄙人的愚见，只能做出一个可用的发行版。但真正优秀的发行版需要精细挑选软件包集合，还要处理各种
软件版本的兼容性问题，工作量可不小。但是制作一个自己玩玩的小系统绰绰有余了。

## kvm 系列 {#kvm-系列}

00 : [kvmtool 启动 linux 内核](/post/使用kvmtool启动linux/)  
01 : [制作根文件系统](/post/制作根文件系统/)

## 参考
[1]. [https://zhaohuabing.com/post/2020-02-24-linux-taptun/](https://zhaohuabing.com/post/2020-02-24-linux-taptun/)
